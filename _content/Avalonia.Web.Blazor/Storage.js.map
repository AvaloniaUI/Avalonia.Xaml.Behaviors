{
  "version": 3,
  "sources": ["../webapp/modules/Storage/IndexedDbWrapper.ts", "../webapp/modules/Storage/StorageProvider.ts"],
  "sourcesContent": ["class InnerDbConnection {\r\n    constructor(private database: IDBDatabase) { }\r\n\r\n    private openStore(store: string, mode: IDBTransactionMode): IDBObjectStore {\r\n        const tx = this.database.transaction(store, mode);\r\n        return tx.objectStore(store);\r\n    }\r\n\r\n    public put(store: string, obj: any, key?: IDBValidKey): Promise<IDBValidKey> {\r\n        const os = this.openStore(store, \"readwrite\");\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const response = os.put(obj, key);\r\n            response.onsuccess = () => {\r\n                resolve(response.result);\r\n            };\r\n            response.onerror = () => {\r\n                reject(response.error);\r\n            };\r\n        });\r\n    }\r\n\r\n    public get(store: string, key: IDBValidKey): any {\r\n        const os = this.openStore(store, \"readonly\");\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const response = os.get(key);\r\n            response.onsuccess = () => {\r\n                resolve(response.result);\r\n            };\r\n            response.onerror = () => {\r\n                reject(response.error);\r\n            };\r\n        });\r\n    }\r\n\r\n    public delete(store: string, key: IDBValidKey): Promise<void> {\r\n        const os = this.openStore(store, \"readwrite\");\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const response = os.delete(key);\r\n            response.onsuccess = () => {\r\n                resolve();\r\n            };\r\n            response.onerror = () => {\r\n                reject(response.error);\r\n            };\r\n        });\r\n    }\r\n\r\n    public close() {\r\n        this.database.close();\r\n    }\r\n}\r\n\r\nexport class IndexedDbWrapper {\r\n    constructor(private databaseName: string, private objectStores: [string]) {\r\n    }\r\n\r\n    public connect(): Promise<InnerDbConnection> {\r\n        const conn = window.indexedDB.open(this.databaseName, 1);\r\n\r\n        conn.onupgradeneeded = event => {\r\n            const db = (<IDBRequest<IDBDatabase>>event.target).result;\r\n            this.objectStores.forEach(store => {\r\n                db.createObjectStore(store);\r\n            });\r\n        };\r\n\r\n        return new Promise((resolve, reject) => {\r\n            conn.onsuccess = event => {\r\n                resolve(new InnerDbConnection((<IDBRequest<IDBDatabase>>event.target).result));\r\n            };\r\n            conn.onerror = event => {\r\n                reject((<IDBRequest<IDBDatabase>>event.target).error);\r\n            };\r\n        });\r\n    }\r\n}\r\n", "\uFEFFimport { IndexedDbWrapper } from \"./IndexedDbWrapper\";\r\n\r\ndeclare global {\r\n    type WellKnownDirectory = \"desktop\" | \"documents\" | \"downloads\" | \"music\" | \"pictures\" | \"videos\";\r\n    type StartInDirectory = WellKnownDirectory | FileSystemHandle;\r\n    interface OpenFilePickerOptions {\r\n        startIn?: StartInDirectory\r\n    }\r\n    interface SaveFilePickerOptions {\r\n        startIn?: StartInDirectory\r\n    }\r\n}\r\n\r\nconst fileBookmarksStore: string = \"fileBookmarks\";\r\nconst avaloniaDb = new IndexedDbWrapper(\"AvaloniaDb\", [\r\n    fileBookmarksStore\r\n]);\r\n\r\nclass StorageItem {\r\n    constructor(public handle: FileSystemHandle, private bookmarkId?: string) { }\r\n\r\n    public getName(): string {\r\n        return this.handle.name\r\n    }\r\n\r\n    public getKind(): string {\r\n        return this.handle.kind;\r\n    }\r\n\r\n    public async openRead(): Promise<Blob> {\r\n        if (!(this.handle instanceof FileSystemFileHandle)) {\r\n            throw new Error(\"StorageItem is not a file\");\r\n        }\r\n\r\n        await this.verityPermissions('read');\r\n\r\n        const file = await this.handle.getFile();\r\n        return file;\r\n    }\r\n\r\n    public async openWrite(): Promise<FileSystemWritableFileStream> {\r\n        if (!(this.handle instanceof FileSystemFileHandle)) {\r\n            throw new Error(\"StorageItem is not a file\");\r\n        }\r\n\r\n        await this.verityPermissions('readwrite');\r\n\r\n        return await this.handle.createWritable({ keepExistingData: true });\r\n    }\r\n\r\n    public async getProperties(): Promise<{ Size: number, LastModified: number, Type: string } | null> {\r\n        const file = this.handle instanceof FileSystemFileHandle\r\n            && await this.handle.getFile();\r\n\r\n        if (!file) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            Size: file.size,\r\n            LastModified: file.lastModified,\r\n            Type: file.type\r\n        }\r\n    }\r\n\r\n    public async getItems(): Promise<StorageItems> {\r\n        if (this.handle.kind !== \"directory\"){\r\n            return new StorageItems([]);\r\n        }\r\n        \r\n        const items: StorageItem[] = [];\r\n        for await (const [key, value] of (this.handle as any).entries()) {\r\n            items.push(new StorageItem(value));\r\n        }\r\n        return new StorageItems(items);\r\n    }\r\n    \r\n    private async verityPermissions(mode: FileSystemPermissionMode): Promise<void | never> {\r\n        if (await this.handle.queryPermission({ mode }) === 'granted') {\r\n            return;\r\n        }\r\n\r\n        if (await this.handle.requestPermission({ mode }) === \"denied\") {\r\n            throw new Error(\"Read permissions denied\");\r\n        }\r\n    }\r\n\r\n    public async saveBookmark(): Promise<string> {\r\n        // If file was previously bookmarked, just return old one.\r\n        if (this.bookmarkId) {\r\n            return this.bookmarkId;\r\n        }\r\n        \r\n        const connection = await avaloniaDb.connect();\r\n        try {\r\n            const key = await connection.put(fileBookmarksStore, this.handle, this.generateBookmarkId());\r\n            return <string>key;\r\n        }\r\n        finally {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n    public async deleteBookmark(): Promise<void> {\r\n        if (!this.bookmarkId) {\r\n            return;\r\n        }\r\n\r\n        const connection = await avaloniaDb.connect();\r\n        try {\r\n            const key = await connection.delete(fileBookmarksStore, this.bookmarkId);\r\n        }\r\n        finally {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n    private generateBookmarkId(): string {\r\n        return Date.now().toString(36) + Math.random().toString(36).substring(2);\r\n    }\r\n}\r\n\r\nclass StorageItems {\r\n    constructor(private items: StorageItem[]) { }\r\n\r\n    public count(): number {\r\n        return this.items.length;\r\n    }\r\n\r\n    public at(index: number): StorageItem {\r\n        return this.items[index];\r\n    }\r\n}\r\n\r\nexport class StorageProvider {\r\n\r\n    public static canOpen(): boolean {\r\n        return typeof window.showOpenFilePicker !== 'undefined';\r\n    }\r\n\r\n    public static canSave(): boolean {\r\n        return typeof window.showSaveFilePicker !== 'undefined';\r\n    }\r\n\r\n    public static canPickFolder(): boolean {\r\n        return typeof window.showDirectoryPicker !== 'undefined';\r\n    }\r\n\r\n    public static async selectFolderDialog(\r\n        startIn: StorageItem | null)\r\n        : Promise<StorageItem> {\r\n\r\n        // 'Picker' API doesn't accept \"null\" as a parameter, so it should be set to undefined.\r\n        const options: DirectoryPickerOptions = {\r\n            startIn: (startIn?.handle || undefined)\r\n        };\r\n\r\n        const handle = await window.showDirectoryPicker(options);\r\n        return new StorageItem(handle);\r\n    }\r\n\r\n    public static async openFileDialog(\r\n        startIn: StorageItem | null, multiple: boolean,\r\n        types: FilePickerAcceptType[] | null, excludeAcceptAllOption: boolean)\r\n        : Promise<StorageItems> {\r\n\r\n        const options: OpenFilePickerOptions = {\r\n            startIn: (startIn?.handle || undefined),\r\n            multiple,\r\n            excludeAcceptAllOption,\r\n            types: (types || undefined)\r\n        };\r\n\r\n        const handles = await window.showOpenFilePicker(options);\r\n        return new StorageItems(handles.map((handle: FileSystemHandle) => new StorageItem(handle)));\r\n    }\r\n\r\n    public static async saveFileDialog(\r\n        startIn: StorageItem | null, suggestedName: string | null,\r\n        types: FilePickerAcceptType[] | null, excludeAcceptAllOption: boolean)\r\n        : Promise<StorageItem> {\r\n\r\n        const options: SaveFilePickerOptions = {\r\n            startIn: (startIn?.handle || undefined),\r\n            suggestedName: (suggestedName || undefined),\r\n            excludeAcceptAllOption,\r\n            types: (types || undefined)\r\n        };\r\n\r\n        const handle = await window.showSaveFilePicker(options);\r\n        return new StorageItem(handle);\r\n    }\r\n\r\n    public static async openBookmark(key: string): Promise<StorageItem | null> {\r\n        const connection = await avaloniaDb.connect();\r\n        try {\r\n            const handle = await connection.get(fileBookmarksStore, key);\r\n            return handle && new StorageItem(handle, key);\r\n        }\r\n        finally {\r\n            connection.close();\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["InnerDbConnection", "database", "store", "mode", "obj", "key", "os", "resolve", "reject", "response", "IndexedDbWrapper", "databaseName", "objectStores", "conn", "event", "db", "fileBookmarksStore", "avaloniaDb", "IndexedDbWrapper", "StorageItem", "handle", "bookmarkId", "__async", "file", "StorageItems", "items", "iter", "__forAwait", "more", "temp", "error", "key", "value", "mode", "connection", "index", "StorageProvider", "startIn", "options", "multiple", "types", "excludeAcceptAllOption", "handles", "suggestedName"]
}
